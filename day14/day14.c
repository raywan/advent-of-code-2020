/*
 * CREATED: 2020/12/14
 * AUTHOR: Raymond Wan
 * https://adventofcode.com/2020/day/14
*/

#include <stdio.h>
#include <stdint.h>

#if defined(_WIN32)
#include <intrin.h>
#else
#include <x86intrin.h>
#endif

#define PART_1_ANSWER 8566770985168
#define PART_2_ANSWER 4832039794082

#define MAX_LINE_LEN 64
#define MASK_BIT_LEN 36
#define MAX_FLOATING_BITS 9
#define NUM_HASH_TABLE_ENTRIES 91183
#define NUM_LINEAR_PROBE_ENTRIES 8

static uint16_t xperms[1024];
static int num_perms = 0;

typedef struct HTEntry {
    uint8_t num_entries;
    uint64_t addresses[NUM_LINEAR_PROBE_ENTRIES];
    uint64_t values[NUM_LINEAR_PROBE_ENTRIES];
} HTEntry;

void generate_bit_permutations(uint16_t perm, int i, int len) {
    if (i == len) {
        xperms[num_perms] = perm;
        num_perms++;
        return;
    }

    perm &= ~(1 << (len - i - 1));
    generate_bit_permutations(perm, i+1, len);

    perm |= (1 << (len - i - 1));
    generate_bit_permutations(perm, i+1, len);
}

inline void parse_mask_str(char mask_str[MAX_LINE_LEN], 
                          uint64_t *out_one_mask, uint64_t *out_zero_mask, uint64_t *out_x_mask) {
    *out_one_mask = 0;
    *out_zero_mask = 0;
    *out_x_mask = 0;
    for (uint64_t i = 0; i < MASK_BIT_LEN; i++) {
        switch (mask_str[i]) {
            case 'X': 
                *out_x_mask |= (1LL << (MASK_BIT_LEN - i-1));
                break;
            case '1': 
                *out_one_mask |= (1LL << (MASK_BIT_LEN - i-1));
                break;
            case '0': 
                *out_zero_mask |= (1LL << (MASK_BIT_LEN - i-1));
                break;
            default: break;
        }
    }
    *out_zero_mask = ~(*out_zero_mask);
}

inline uint16_t parse_address(char *line) {
    int num_digits = 0;
    for (num_digits = 0; line[num_digits] >= '0' && line[num_digits] <= '9'; num_digits++) {}
    uint16_t result = 0;
    uint16_t digit = 1;
    for (int i = 0; i < num_digits; i++) {
        result += digit * (line[num_digits-i-1] - '0');
        digit *= 10;
    }
    return result;
}

inline uint64_t apply_v1_mask(uint64_t val, uint64_t one_mask, uint64_t zero_mask) {
    return (val | one_mask) & zero_mask;
}

// Version 2 masks the address instead of the value
inline void apply_v2_mask(HTEntry *mem_ht, uint64_t memory[UINT16_MAX], uint16_t addr, uint64_t val,
                          uint64_t one_mask, uint64_t x_mask) {
    // Count the number of floating bits to know how many permutations to iterate
    int num_permutations = 1 << __popcnt64(x_mask);
    uint64_t masked_addr = addr | one_mask;

    for (int i = 0; i < num_permutations; i++) {
        uint64_t permuted_addr = masked_addr;
        int cur_perm_bit = 0;
        uint64_t tmp_mask = x_mask;
        for (int j = 0; tmp_mask >> j; j++) {
            if ((tmp_mask >> j) & 0x1) {
               if ((xperms[i] >> cur_perm_bit) & 0x1) {
                    permuted_addr |= (1LLU << j);
               } else {
                    permuted_addr &= ~(1LLU << j);
               }
               cur_perm_bit++;
            }
        }

        if (!mem_ht[permuted_addr % NUM_HASH_TABLE_ENTRIES].num_entries) {
            mem_ht[permuted_addr % NUM_HASH_TABLE_ENTRIES].addresses[0] = permuted_addr;
            mem_ht[permuted_addr % NUM_HASH_TABLE_ENTRIES].values[0] = val;
            mem_ht[permuted_addr % NUM_HASH_TABLE_ENTRIES].num_entries = 1;
        } else {
            int found = 0;
            for (int j = 0; j < mem_ht[permuted_addr % NUM_HASH_TABLE_ENTRIES].num_entries; j++) {
                if (permuted_addr == mem_ht[permuted_addr % NUM_HASH_TABLE_ENTRIES].addresses[j]) {
                    mem_ht[permuted_addr % NUM_HASH_TABLE_ENTRIES].values[j] = val;
                    found = 1;
                    break;
                }
            }
            if (!found) {
                int idx = mem_ht[permuted_addr % NUM_HASH_TABLE_ENTRIES].num_entries;
                mem_ht[permuted_addr % NUM_HASH_TABLE_ENTRIES].addresses[idx] = permuted_addr;
                    mem_ht[permuted_addr % NUM_HASH_TABLE_ENTRIES].values[idx] = val;
                mem_ht[permuted_addr % NUM_HASH_TABLE_ENTRIES].num_entries++;
            }
        }
    }
}

/*
 * Total time contains both part 1 and 2 because they can be computed in the same pass
 * 18341.9us (-Od) / 10559.7us (-O2)
 * For the given input, part 2 makes 91168 writes to "memory addresses" in total
 * The timings scale with the number of bit permutations generated by the mask
 * 
 * Timings from a two run samples: 
 * |---------------------------------------------------------------------------------|
 * |              |          |           -Od             |           -O2             |
 * | # float bits |  # hits  |---------------------------|---------------------------|
 * |              |          | Total (us) | Average (us) | Total (us) | Average (us) |
 * |--------------+----------+------------+--------------+------------+--------------|
 * |      5       |    72    |   204.7    |     2.84     |   106.1    |    1.47      |
 * |      6       |    59    |   321.8    |     5.45     |   175.5    |    2.97      |
 * |      7       |    51    |   609.9    |     11.95    |   323.6    |    6.3       |
 * |      8       |    127   |   3237.9   |     25.49    |   1597.2   |    12.58     |
 * |      9       |    66    |   2981.7   |     45.18    |   1575.2   |    23.87     |
 * |---------------------------------------------------------------------------------|
 */

int main() {
    FILE *f = fopen("d14_input.txt", "rb");

    // Precompute bit permutations
    generate_bit_permutations(0, 0, MAX_FLOATING_BITS);

    HTEntry *mem_ht = (HTEntry *) malloc(sizeof(HTEntry) * NUM_HASH_TABLE_ENTRIES); 
    memset(mem_ht, 0, sizeof(HTEntry) * NUM_HASH_TABLE_ENTRIES);

    uint64_t memory[UINT16_MAX] = {0}; 
    uint64_t one_mask = 0;
    uint64_t zero_mask = 0;
    uint64_t x_mask = 0;
    char lvalue[MAX_LINE_LEN];
    char rvalue[MAX_LINE_LEN];
    for (int n = 0; fscanf(f, "%s = %s", lvalue, rvalue) != EOF; n++) {
        switch (lvalue[1]) {
            case 'a': { // m[a]sk
                parse_mask_str(rvalue, &one_mask, &zero_mask, &x_mask);
            } break;
            case 'e': { // m[e]m
                uint16_t addr = parse_address(&lvalue[4]);
                uint64_t val = atoi(rvalue);
                memory[addr] = apply_v1_mask(val, one_mask, zero_mask);
                apply_v2_mask(mem_ht, memory, addr, val, one_mask, x_mask);
            } break;
        }
    }

    uint64_t mem_sum_v1 = 0;
    for (int i = 0; i < UINT16_MAX; i++) {
        mem_sum_v1 += memory[i];
    }

    uint64_t mem_sum_v2 = 0;
    for (int i = 0; i < NUM_HASH_TABLE_ENTRIES; i++) {
        for (int j = 0; j < mem_ht[i].num_entries; j++) {
            mem_sum_v2 += mem_ht[i].values[j];
        }
    }

    printf("PART 1: %llu (expected %llu)\n", mem_sum_v1, PART_1_ANSWER);
    printf("PART 2: %llu (expected %llu)\n", mem_sum_v2, PART_2_ANSWER);

    free(mem_ht);
    fclose(f);
    return 0;
}
